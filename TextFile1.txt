register
zr 0000
r1 0001
r2 0010
r3 0011
r4 0100
r5 0101
r6 0110
r7 0111
r8 1000
r9 1001
r10 1010
r11 1011
r12 1100
r13 1101
sp 1110
flags 1111

[instructions]

nop
    00000000 00000000 00000000 00000000
    Does nothing

in %a(register)
    00000001 aaaa0000 00000000 00000000
    Loads an input and stores it in %a

out
    out %a(register)
    00000010 00000000 0000aaaa 00000000
    Sends %a to output

    out %a(immediate)
    00010010 00000000 aaaaaaaa aaaaaaaa
    Sends %a to output

console
    console %a(register)
    00000011 00000000 0000aaaa 00000000
    Stores the value of %a in the console offset register

    console %a(immediate)
    00010011 00000000 aaaaaaaa aaaaaaaa
    Stores the value of %a in the console offset register

time
    time_0 %a(register)
    00000100 aaaa0000 00000000 00000000
    Loads the two least significant bytes of the time value and stores it to %a

    time_1 %a(register)
    00000101 aaaa0000 00000000 00000000
    Loads the second two bytes of the time value and stores it to %a

    time_2 %a(register)
    00000110 aaaa0000 00000000 00000000
    Loads the third two bytes of the time value and stores it to %a

    time_3 %a(register)
    00000111 aaaa0000 00000000 00000000
    Loads the two most significant bytes of the time value and stores it to %a

counter %a(register)
    00001000 aaaa0000 00000000 00000000
    Loads the counter value and stores it to %a

keyboard %a(register)
    00001001 aaaa0000 00000000 00000000
    Loads keyboard input and stores it to %a



alu without an immediate
    nand %a(register), %b(register), %c(register)
    00100000 aaaabbbb 0000cccc 00000000
    NAND %b and %c and store the result in %a.

    or %a(register), %b(register), %c(register)
    00100001 aaaabbbb 0000cccc 00000000
    OR %b and %c and store the result in %a.

    and %a(register), %b(register), %c(register)
    00100010 aaaabbbb 0000cccc 00000000
    AND %b and %c and store the result in %a.

    nor %a(register), %b(register), %c(register)
    00100011 aaaabbbb 0000cccc 00000000
    NOR %b and %c and store the result in %a.

    add %a(register), %b(register), %c(register)
    00100100 aaaabbbb 0000cccc 00000000
    ADD %b and %c and store the result in %a.

    sub %a(register), %b(register), %c(register)
    00100101 aaaabbbb 0000cccc 00000000
    SUB %b and %c and store the result in %a.

    xor %a(register), %b(register), %c(register)
    00100110 aaaabbbb 0000cccc 00000000
    XOR %b and %c and store the result in %a.

    lsl %a(register), %b(register), %c(register)
    00100111 aaaabbbb 0000cccc 00000000
    Logical shift left %b by %c and store the result in %a.

    lsr %a(register), %b(register), %c(register)
    00101000 aaaabbbb 0000cccc 00000000
    Logical shift right %b by %c and store the result in %a.

    cmp %a(register), %b(register)
    00101001 1111aaaa 0000bbbb 00000000
    Compares %a and %b and store the resulting flags in 'flags'.

    mul %a(register), %b(register), %c(register)
    00101010 aaaabbbb 0000cccc 00000000
    MUL %b and %c and store the result in %a.

alu with an immediate
    nand %a(register), %b(register), %c(immediate)
    00110000 aaaabbbb cccccccc cccccccc
    NAND %b and %c and store the result in %a.

    or %a(register), %b(register), %c(immediate)
    00110001 aaaabbbb cccccccc cccccccc
    OR %b and %c and store the result in %a.

    nor %a(register), %b(register), %c(immediate)
    00110011 aaaabbbb cccccccc cccccccc
    NOR %b and %c and store the result in %a.

    and %a(register), %b(register), %c(immediate)
    00110010 aaaabbbb cccccccc cccccccc
    AND %b and %c and store the result in %a.

    add %a(register), %b(register), %c(immediate)
    00110100 aaaabbbb cccccccc cccccccc
    ADD %b and %c and store the result in %a.

    sub %a(register), %b(register), %c(immediate)
    00110101 aaaabbbb cccccccc cccccccc
    SUB %b and %c and store the result in %a.

    xor %a(register), %b(register), %c(immediate)
    00110110 aaaabbbb cccccccc cccccccc
    XOR %b and %c and store the result in %a.

other alu instructions
    lsl %a(register), %b(register), %c(immediate)
    00110111 aaaabbbb cccccccc cccccccc
    Logical shift left %b by %c and store the result in %a.

    lsr %a(register), %b(register), %c(immediate)
    00111000 aaaabbbb cccccccc cccccccc
    Logical shift right %b by %c and store the result in %a.

    cmp %a(register), %b(immediate)
    00111001 1111aaaa bbbbbbbb bbbbbbbb
    Compares %a and %b and store the resulting flags in 'flags'.

    mul %a(register), %b(register), %c(immediate)
    00111010 aaaabbbb cccccccc cccccccc
    MUL %b and %c and store the result in %a.

    mov %b(register), %a(register)
    00100100 bbbbaaaa 00000000 00000000
    Moves %b to %a

    not %a(register), %b(register)
    00110110 aaaabbbb 11111111 11111111
    not a and store the result at b

    neg %a(register), %b(register)
    00111010 aaaabbbb 11111111 11111111
    negate a and store the result at b

jumps
    jmp %a(register)
    01001000 00001111 0000aaaa 00000000
    Jump to %a

    jmp %a(immediate | label)
    01011000 00001111 aaaaaaaa aaaaaaaa
    Jump to %a

conditional jumps
    je %a(immediate | label)
    01010001 00001111 aaaaaaaa aaaaaaaa
    Jump to %a if the values were equal (reading results from 'flags').

    jne %a(immediate | label)
    01011001 00001111 aaaaaaaa aaaaaaaa
    Jump to %a if the values were not equal (reading results from 'flags').


    jl %a(immediate | label)
    01010100 00001111 aaaaaaaa aaaaaaaa
    Jump to %a if the first value was less (signed) than the second (reading results from 'flags').

    jge %a(immediate | label)
    01011100 00001111 aaaaaaaa aaaaaaaa
    Jump to %a if the first value was greater (signed) or equal to the second (reading results from 'flags').

    jle %a(immediate | label)
    01010101 00001111 aaaaaaaa aaaaaaaa
    Jump to %a if the first value was less (signed) or equal to the second (reading results from 'flags').

    jg %a(immediate | label)
    01011101 00001111 aaaaaaaa aaaaaaaa
    Jump to %a if the first value was greater (signed) than the second (reading results from 'flags').


    jb %a(immediate | label)
    01010010 00001111 aaaaaaaa aaaaaaaa
    Jump to %a if the first value was below (unsigned) the second (reading results from 'flags').

    jae %a(immediate | label)
    01011010 00001111 aaaaaaaa aaaaaaaa
    Jump to %a if the first value was above (unsigned) or equal to the second (reading results from 'flags').

    jbe %a(immediate | label)
    01010011 00001111 aaaaaaaa aaaaaaaa
    Jump to %a if the First value was below (unsigned) or equal to the second (reading results from 'flags').

    ja %a(immediate | label)
    01011011 00001111 aaaaaaaa aaaaaaaa
    Jump to %a if the first value was above (unsigned) the second (reading results from 'flags').


RAM
    load_8 %dest(register), [%address(register)]
    01100000 dddd0000 0000aaaa 00000000
    Loads %address from RAM and stores it to %dest

    load_8 %dest(register), [%address(immediate)]
    01110000 dddd0000 aaaaaaaa aaaaaaaa
    Loads %address from RAM and stores it to %dest

    store_8 [%address(register)], %value(register)
    01100001 0000vvvv 0000aaaa 00000000
    Store %value to %address in RAM

    store_8 [%address(immediate)], %value(register)
    01110001 0000vvvv aaaaaaaa aaaaaaaa
    Store %value to %address in RAM

    load_16 %dest(register), [%address(register)]
    01100010 dddd0000 0000aaaa 00000000
    Loads %address from RAM and stores it to %dest

    load_16 %dest(register), [%address(immediate)]
    01110010 dddd0000 aaaaaaaa aaaaaaaa
    Loads %address from RAM and stores it to %dest

    store_16 [%address(register)], %value(register)
    01100011 0000vvvv 0000aaaa 00000000
    Store %value to %address in RAM

    store_16 [%address(immediate)], %value(register)
    01110011 0000vvvv aaaaaaaa aaaaaaaa
    Store %value to %address in RAM

SSD

    pload_8 %dest(register), [%address(register)]
    01100100 dddd0000 0000aaaa 00000000
    Loads %address from SSD and stores it to %dest

    pload_8 %dest(register), [%address(immediate)]
    01110100 dddd0000 aaaaaaaa aaaaaaaa
    Loads %address from SSD and stores it to %dest

    pstore_8 [%address(register)], %value(register)
    01100101 0000vvvv 0000aaaa 00000000
    Store %value to %address in SSD

    pstore_8 [%address(immediate)], %value(register)
    01110101 0000vvvv aaaaaaaa aaaaaaaa
    Store %value to %address in SSD

    pload_16 %dest(register), [%address(register)]
    01100110 dddd0000 0000aaaa 00000000
    Loads %address from SSD and stores it to %dest

    pload_16 %dest(register), [%address(immediate)]
    01110110 dddd0000 aaaaaaaa aaaaaaaa
    Loads %address from SSD and stores it to %dest

    pstore_16 [%address(register)], %value(register)
    01100111 0000vvvv 0000aaaa 00000000
    Store %value to %address in SSD

    pstore_16 [%address(immediate)], %value(register)
    01110111 0000vvvv aaaaaaaa aaaaaaaa
    Store %value to %address in SSD